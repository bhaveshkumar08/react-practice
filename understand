import React, { Component } from "react";
import PropTypes from "prop-types";
import { GoogleAdsConfig, getTargeting, adLogger } from "utils/GoogleAdsHelper";
import { saveInSessionStorage, getDataFromSessionStorage } from "utils/storageHelper";
import { logEvent } from "logger";
import { fmgAds } from "utils/eventNames";
import { connect } from "react-redux";

class GoogleAds extends Component {
    constructor(props) {
        super(props);
        this.state = {
            loading: false
        };
        this.adSlot = null;
        this.refreshTimer = null;
        this.refreshBasedOnTime = false;
        this.refreshBasedOnViewability = false;
        this.listenersAdded = false;
        this._isMounted = false;
    }

    componentDidMount() {
        this._isMounted = true;
        adLogger.log("GPT:Mount Refresh Time for:", this.props.adUnitPath, this.props.refreshTime);
        this.defineAdSlots();
    }

    componentDidUpdate(prevProps) {
        if (this.adSlot && prevProps.userDetails !== this.props.userDetails) {
            const targeting = getTargeting(this.props.criteria, this.props.placement, this.props.userDetails);

            Object.keys(targeting).forEach((key) => {
                this.adSlot.setTargeting(key, targeting[key]);
            });

            window.googletag.pubads().refresh([this.adSlot], { changeCorrelator: false });
        }
    }

    componentWillUnmount() {
        this._isMounted = false;
        adLogger.log("GPT: Unmounting", this.props.adUnitPath);

        if(this.listenersAdded) {
            // Remove listeners
            window.removeEventListener("gpt-ad-requested", this.handleSlotRequested);
            window.removeEventListener("gpt-ad-rendered", this.handleSlotRenderEnded);
            window.removeEventListener("gpt-ad-impression-viewable", this.setViewed);
            window.removeEventListener("gpt-ad-visibility-changed", this.handleSlotVisibilityChange);
            this.listenersAdded = false;
        }
        if (this.adSlot && window.googletag?.destroySlots) {
            window.googletag.destroySlots([this.adSlot]);
            this.adSlot = null;
        }
        if (this.refreshTimer) {
            clearTimeout(this.refreshTimer);
            this.refreshTimer = null;
        } 
    }

    defineAdSlots() {
        try {
            window.googletag = window.googletag || { cmd: [] };
            window.googletag.cmd.push(() => {
                if (!this._isMounted) return;

                const pubads = window.googletag.pubads();
                // Define slot
                this.adSlot = window.googletag.defineSlot(this.props.adUnitPath, this.props.slotSize, this.props.id).addService(pubads);
                if (this.adSlot) {
                    // Set targeting
                    const targeting = getTargeting(this.props.criteria, this.props.placement, this.props.userDetails);
                    Object.keys(targeting).forEach((key) => {
                        this.adSlot.setTargeting(key, targeting[key]);
                    });
                        
                    this.initGpt(pubads);

                    // Add listeners
                    this.attachListeners();

                    window.googletag.display(this.props.id);

                    saveInSessionStorage("_adRefreshTime_", new Date());
                }
            });
        } catch {}
    };

    initGpt = (pubads) => {
        try {
            if (!window.gptAdsServicesEnabled) {
                window.googletag.pubads().enableSingleRequest();
                window.googletag.enableServices();
                window.gptAdsServicesEnabled = true;
            }
            if (!window.gptAdsEnableLazyLoading && window.cockpitSetting.ApplicationSettings.EnableLazyLoadingForAds) {
                // Enable lazy loading
                pubads.enableLazyLoad({
                    fetchMarginPercent: 0,  // Fetch only when entering viewport
                    renderMarginPercent: 0, // Render only when actually visible
                    mobileScaling: 1.0        // Adjusts margins for mobile
                });
                window.gptAdsEnableLazyLoading = true;
            }
            this.globalGptAdsListeners(pubads);
        } catch {}
    };

    globalGptAdsListeners = (pubads) => {
        try {
            if(window.globalGptAdsListenersAdded) return;
            pubads.addEventListener("slotRequested", (event) => {
                window.dispatchEvent(new CustomEvent("gpt-ad-requested", { detail: event }));
            });
            pubads.addEventListener("slotRenderEnded", (event) => {
                window.dispatchEvent(new CustomEvent("gpt-ad-rendered", { detail: event }));
            });
            pubads.addEventListener("impressionViewable", (event) => {
                window.dispatchEvent(new CustomEvent("gpt-ad-impression-viewable", { detail: event }));
            });
            pubads.addEventListener("slotVisibilityChanged", (event) => {
                window.dispatchEvent(new CustomEvent("gpt-ad-visibility-changed", { detail: event }));
            });
            window.globalGptAdsListenersAdded = true;
        } catch {}
    };

    attachListeners = () => {
        if (this.listenersAdded) return;

        window.addEventListener("gpt-ad-requested", this.handleSlotRequested);
        window.addEventListener("gpt-ad-rendered", this.handleSlotRenderEnded);
        window.addEventListener("gpt-ad-impression-viewable", this.setViewed);
        window.addEventListener("gpt-ad-visibility-changed", this.handleSlotVisibilityChange);
        this.listenersAdded = true;
    };

    setViewed = (gptEvent) => {
        try {
            const { adUnitPath, refreshTime, placement } = this.props;
            const slot = gptEvent.detail.slot;
            console.log('################################# evnet', gptEvent);
            adLogger.log("GPT: setViewed called", adUnitPath, slot.getSlotElementId());

            if (slot.getAdUnitPath() === adUnitPath) {
                adLogger.log("GPT: AdViewed setViewed", adUnitPath, refreshTime);
                if (refreshTime && refreshTime > 0) {
                    this.refreshTimer = setTimeout(() => {
                        this.refreshBasedOnTime = true;
                        this.triggerRefresh();
                        this.refreshTimer = null;
                    }, refreshTime);
                }
                if (!window.inlinead_displayed && placement === "Inline-listing-contract") {
                    window.inlinead_displayed = true;
                    logEvent({...fmgAds, Label: "inline_ad_displayed"});
                }
            }
        } catch {}
    };

    triggerRefresh = () => {
        try {
            const { adUnitPath } = this.props;
            adLogger.log("GPT: Refresh check", "time:", this.refreshBasedOnTime, "viewability:", this.refreshBasedOnViewability, adUnitPath);

            if (this.refreshBasedOnTime && this.refreshBasedOnViewability && this.adSlot && this._isMounted) {
                adLogger.log("_adRefreshTime_" + JSON.stringify(getDataFromSessionStorage("_adRefreshTime_")));
                adLogger.log("GPT: refreshing now:", adUnitPath, new Date());
                this.refreshBasedOnTime = false;
                this.refreshBasedOnViewability = false;
                window.googletag.pubads().refresh([this.adSlot], { changeCorrelator: false });
                saveInSessionStorage("_adRefreshTime_", new Date());
            }
        } catch {}
    };

    handleSlotVisibilityChange = (gptEvent) => {
        try {
            const { adUnitPath } = this.props;
            const slot = gptEvent.detail.slot;
            const inViewPercentage = gptEvent.detail.inViewPercentage || 0;
            adLogger.log("GPT: handleAdRefresh called due to SLOT_VISIBILITY_CHANGED", adUnitPath, inViewPercentage);

            if (slot.getAdUnitPath() === adUnitPath) {
                const perc = GoogleAdsConfig.inViewPerc || 50;
                const shouldRefresh = window.cockpitSetting.ApplicationSettings.EnableRefreshBasedOnViewability ? inViewPercentage >= perc : true;
                if (shouldRefresh) {
                    this.refreshBasedOnViewability = true;
                    this.triggerRefresh();
                } else {
                    adLogger.log("GPT: setting refreshBasedOnViewability to false", adUnitPath);
                    this.refreshBasedOnViewability = false;
                }
            }
        } catch {}
    };

    handleSlotRequested = (gptEvent) => {
        try {
            // Detect if this slot has previously rendered
            const hasRenderedBefore = !!gptEvent.detail.slot.getResponseInformation();
            if (hasRenderedBefore && gptEvent.detail.slot.getSlotElementId() === this.props.id) {
                // Add dynamic inline styling
                this.setState({ loading: true });
            }
        } catch {}
    };

    handleSlotRenderEnded = (gptEvent) => {
        try {
            if (gptEvent.detail.slot.getSlotElementId() === this.props.id) {
                if (this.refreshTimer) {
                    clearTimeout(this.refreshTimer);
                    this.refreshTimer = null;
                    this.refreshBasedOnTime = false;
                    this.refreshBasedOnViewability = false;
                }
                // Remove dynamic inline styling
                this.setState({ loading: false });
            }
        } catch {}
    };

    render() {
        const { id, slotSize } = this.props;
        let style = {};

        if (this.state.loading && this.adSlot && Array.isArray(slotSize) && slotSize.length === 2) {
            // Dynamic inline styling
            const [width, height] = slotSize;
            style = { width: `${width}px`, height: `${height}px` };
        }
        return (
            // a div placeholder for the GPT slot
            <div id={id} style={style} />
        );
    }
}

GoogleAds.propTypes = {
    id: PropTypes.string.isRequired,
    adUnitPath: PropTypes.string.isRequired,
    slotSize: PropTypes.oneOfType([PropTypes.array, PropTypes.string]),
};

const mapStateToProps = (state) => ({
    userDetails: state.userDetails,
});

export { GoogleAds, mapStateToProps };
export default connect(mapStateToProps)(GoogleAds);
